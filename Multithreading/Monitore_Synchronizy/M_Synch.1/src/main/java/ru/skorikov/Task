1. класс Count и метод int incremant() [#1102]
  Петр Арсентьев,  21.12.17 2:10
Давайте решим классическую задачу связанную с параллельным увеличением счетчика.

Нам необходимо создать класс, который будет иметь два метода: увеличить внутренне поле на 1
и второй метод - получить значение этого поля.

Давайте напишем код.

package ru.job4j;

public class Count {
    private int value;

    public void increment() {
        this.value++;
    }

    public int get() {
        return this.value;
    }
}

Код получился у нас минималистичным!

Давайте напишем на него тест, который будет демонстрировать применения данного кода.

Тест у нас будет состоять из двух нитей.
Каждая нить будет дергать счетчик и увеличивать его значение на единицу.
В конце теста мы проверим, что наш счетчик увеличился на нужное количество раз.

package ru.job4j;

import org.junit.Test;
import static org.hamcrest.Matchers.is;
import static org.junit.Assert.assertThat;

public class CountTest {

    /**
     * Класс описывает нить со счетчиком.
     */
    private class ThreadCount extends Thread {
        private final Count count;

        private ThreadCount(final Count count) {
            this.count = count;
        }

        @Override
        public void run() {
            this.count.increment();
        }
    }

    @Test
    public void whenExecute2ThreadThen2() throws InterruptedException {
        //Создаем счетчик.
        final Count count = new Count();
        //Создаем нити.
        Thread first = new ThreadCount(count);
        Thread second = new ThreadCount(count);
        //Запускаем нити.
        first.start();
        second.start();
        //Заставляем главную нить дождаться выполнения наших нитей.
        first.join();
        second.join();
        //Проверяем результат.
        assertThat(count.get(), is(2));

    }
}

Как мы видим все тестирование с нитями сводиться к тестирования последовательных операций.
Этого мы достигаем за счет использования метода join.

Давайте теперь посмотрим на класс Count.

Оценим, какие он имеет проблемы:

1. Проблема гонок. Общий ресурс не синхронизирован.
2. Проблема видимости общего ресурса. Одна нить считывает данные их кеша, другая из регистра.

Чтобы решить эти проблемы, мы можем воспользоваться ключевым словом synchronized.

Для того, чтобы правильно определить, какие методы нам нужно синхронизировать, нам нужно определить общие ресурсы.

В наборе Java программиста есть удобный инструмент, который позволяет понять,
где у нас общие ресурсы и как мы их синхронизируем.

Для этого нам нужно подключить к нашему проекту библиотеку
jcip-annotations
<dependency>
    <groupId>net.jcip</groupId>
    <artifactId>jcip-annotations</artifactId>
    <version>1.0</version>
</dependency>
В этой библиотеке есть аннотации, которыми мы описываем класс.
Это нужно делать, чтобы облегчить понимание, где общие ресурсы и как мы их синхронизируем.

САМА БИБЛИОТЕКА СИНХРОНИЗАЦИЮ НЕ ОБЕСПЕЧИВАЕТ. Она только информирует программиста,
о том что у нас есть общие ресурсы и нам нужно аккуратно с ними работать.

Давайте теперь добавим аннотации к нашему классу Count.

package ru.job4j;

import net.jcip.annotations.GuardedBy;
import net.jcip.annotations.ThreadSafe;

@ThreadSafe
public class Count {
    @GuardedBy("this")
    private int value;

    public void increment() {
        this.value++;
    }

    public int get() {
        return this.value;
    }
}
@ThreadSafe - эта аннотация, говорит пользователям данного класса, что класс можно использовать
в многопоточном режиме
и он будет работать правильно.

@GuardedBy("this") - эта аннотация выставляется над общим ресурсом. Аннотация имеет входящий параметр.
Он указывает на объект монитора,
по которому мы будет синхронизироваться.
Программист должен работать с этим ресурсом только в критической секции,
которая синхронизируется по объекту монитора, который указан в аннотации.

Если мы запустим тест заново, то результат будет прежним.
Хотя класс Count все еще написан не верно.

Среда разработки IDEA позволяет указать разработчику на проблемный код, который описан через аннотации jcip.

Для этого нужно включить режим индикации этих аннотаций.

Заходим в настройки IDEA



В поиске набираем jcip



Отмечаем галками все пункты относящиеся к этой библиотеке.

Теперь откроем код и посмотрим. что среда подсвечивает ошибки.







Так же, такие операторы в среде подсвечены коричневым.



Теперь давайте добавим синхронизацию и посмотрим, что скажет IDEA.



Как мы видим среда теперь показывает, что код верный.

Запомните, что аннотации jcip - это как JavaDoc - он нужен, только чтобы описать класс,
который будет работать в многопоточности.
Синхронизацию эти аннотации не добавляют.

Задание.
1. Сделать класс многопоточный счетчик Count#int incremant().
2. Подключить библиотеку jcip-annotations

https://mvnrepository.com/artifact/net.jcip/jcip-annotations/1.0

Для этого добавить в блок dependencies следующий код.

<dependency>
    <groupId>net.jcip</groupId>
    <artifactId>jcip-annotations</artifactId>
    <version>1.0</version>
</dependency>

3. В заголовке класса указать аннотацию @ThreadSafe

4. Для поля состояния использовать аннотацию @GuardedBy

5. В аннотации GuardedBy - указать объект монитора.